schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}

# The Query type represents all of the entry points into the API.
type Query {
  discussion(id: ID!): Discussion
  listDiscussions: [Discussion!]
  flairTemplates(query: String): [FlairTemplate!]
  # Need to add verification that the caller is the user.
  user(id: ID!): User!
  me: User!

  # Twitter
  twitterUserAutocompletes(query: ID!, discussionID: ID!, invitingParticipantID: ID!): [TwitterUserInfo!]
}

input UpdateParticipantInput {
  gradientColor: GradientColor
  isUnsetGradient: Boolean
  flairID: ID
  isUnsetFlairID: Boolean
  isAnonymous: Boolean
  hasJoined: Boolean
}

input AddDiscussionParticipantInput {
  gradientColor: GradientColor
  flairID: ID
  hasJoined: Boolean
  isAnonymous: Boolean!
}

# TODO: implement
input PollInput {
  pollText: String!,
  endTime: Time!,
  option1: String!,
  option2: String!,
  option3: String,
  option4: String
}

input PostContentInput {
  postText: String!,
  postType: PostType!,
  mentionedEntities:[String!],
  quotedPostID: ID,
  mediaID: ID,
  poll: PollInput,
  importedContentID: ID,
  preview: String
}

input DiscussionInput {
  anonymityType: AnonymityType
  title: String
  autoPost: Boolean
  idleMinutes: Int
  publicAccess: Boolean
  iconURL: String
}

type Mutation {
  addDiscussionParticipant(discussionID: String!, userID: String!, discussionParticipantInput: AddDiscussionParticipantInput!): Participant!
  addPost(discussionID: ID!, participantID: ID!, postContent: PostContentInput!): Post!
  postImportedContent(discussionID: ID!, participantID: ID!, contentID: ID!): Post! # TODO: Need clarity on UX for this. Keeping it simple for now
  scheduleImportedContent(discussionID: ID!, contentID: ID!): ContentQueueRecord!
  createDiscussion(anonymityType: AnonymityType!, title: String!, publicAccess: Boolean = true): Discussion!

  # Creates a User Flair from a Flair template, accessible via available flair
  createFlair(userID: String!, templateID: String!): Flair!
  # Removes a User Flair from a user's available flair
  removeFlair(id: String!): Flair!

  # Assigns a User Flair to a Participant
  assignFlair(participantID: String!, flairID: String!): Participant!
  # Removes a User Flair from a Participant
  unassignFlair(participantID: String!): Participant!

  # Creates a new flair template
  createFlairTemplate(displayName: String, imageURL: String, source: String!): FlairTemplate!
  # Removes a flair template
  removeFlairTemplate(id: String!): FlairTemplate!

  # A slight misnomer here because this will be a copy-on-write. The participant
  # object actually is immutable.
  updateParticipant(discussionID: ID!, participantID: ID!, updateInput: UpdateParticipantInput!): Participant!

  # Upsert user device
  upsertUserDevice(userID: ID, platform: Platform!, deviceID: String!, token: String): UserDevice!

  updateDiscussion(discussionID: ID!, input: DiscussionInput!): Discussion!

  addDiscussionTags(discussionID: ID!, tags:[String!]): [Tag!]
  deleteDiscussionTags(discussionID: ID!, tags:[String!]): [Tag!]

  conciergeMutation(discussionID: ID!, mutationID: ID!, selectedOptions:[String!]): Post! # Heterogeneous endpoint. Think about what we want to return here. Could use entities? What does that gain us?
  # Add flair accessibility to private discussions
  addDiscussionFlairTemplatesAccess(discussionID: ID!, flairTemplateIDs:[ID!]): Discussion!
  deleteDiscussionFlairTemplatesAccess(discussionID: ID!, flairTemplateIDs:[ID!]): Discussion!

  # Invites
  inviteUserToDiscussion(discussionID: ID!, userID: ID!, invitingParticipantID: ID!): DiscussionInvite!
  inviteTwitterUsersToDiscussion(discussionID: ID!, twitterUsers: [TwitterUserInput!], invitingParticipantID: ID!): [DiscussionInvite!]!
  respondToInvite(inviteID: ID!, response: InviteRequestStatus!, discussionParticipantInput: AddDiscussionParticipantInput!): DiscussionInvite!

  requestAccessToDiscussion(discussionID: ID!): DiscussionAccessRequest!
  respondToRequestAccess(requestID: ID!, response: InviteRequestStatus!): DiscussionAccessRequest!

  joinDiscussionWithVIPToken(discussionID: ID!, vipToken: ID!): Discussion!

  # Posts
  deletePost(discussionID: ID!, postID: ID!): Post!

  # Banning
  banParticipant(discussionID: ID!, participantID: ID!): Participant!
}

type Subscription {
  postAdded(discussionID: String!): Post
  onDiscussionEvent(discussionID: String!): DiscussionSubscriptionEvent
}
